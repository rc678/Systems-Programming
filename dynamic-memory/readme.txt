  We opted to try part of the extra credit by including my_calloc. See last paragraph regarding its implementation.
  
  Our implementation of malloc runs in worst case big O(n) time where n is the number of memEntries in the heap. Best case time is O(1) if the very first memEntry is free and can fit the data despite any later memEntries. We use the first-fit algorithm to implement malloc. There is a global array called heap to manage dynamic memory. When malloc is first called, we initialize the root by converting the first few bytes of the heap to the first memEntry. For future calls to malloc, we iterate through the linked list of memEntries located throughout the heap until we either find a free memEntry holding a suitable sized chunk of memory or we reach the last memEntry and there is space to simply add a new one for this new data after it. To check for saturation, we use an int variable to find the relative distance in memory between the beginning of our heap and the point in memory that would be the end of the data we would be allocating in this call if we allocated it at the current memEntry. This will tell us if we are at the last memEntry in the heap, that it can not fit the new data to be allocated, and that there is no room in the heap to allocate a new memEntry. Thus, we break the loop, print an error statement, and return.

  Our implementation of malloc runs in worst and best case big O(1) time. First we check for any errors in the input pointer data. We use an int to find the relative distance between the beginning of our heap and the address of the input data. If this distance is negative or greater than the size of the heap, then the data was never allocated in the first place, so we print an error and return. To determine if the address of the data is in fact within the bounds of the heap, but is not pointing to a valid location that was ever returned from malloc, we pretend to find what would be its corresponding memEntry and check for a valid "free" boolean value. If, this value is not either -1 or 1 as it should be, then the input address is not a valid point for freeing, and we print an error and return. To determine if the data to be freed has already been freed, we simply check if the corresponding memEntry's free boolean is 1. If so, we print an error and return. Otherwise, we should be able to free our data.
  To do this, we first check if the previous memEntry does not exist or if it is in use. If either of these are true, just change the boolean "free" for the current memEntry to 1. Otherwise, we want to increment the previous memEntry's size by the size of the current mementry and its corresponding data. After this, for either case, we check if the NEXT memEntry exists and is freed. If so, we again want to expand the size of the previous memEntry by this memEntry and its data. Otherwise we do not have to do anything else.

  Our implementation of calloc is almost identical to that of malloc. There are only 3 small differences. First, we have an extra error check to make sure that the size of the block is large enough to fit the entire array of elements being allocated. Second, it adjusts the size of the data to be allocated to be the number of elements times the size of each element. Lastly, before returning a pointer to the point of allocation, it set each byte of memory within the chunk of memory being allocated to 0. Again, the running time of this function is worst case big O(n) time, where n is the number of memEntries.
