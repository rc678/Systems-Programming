We used an external macros called uthash to create two hashtables. One hashtable stores the information in database.txt and the other hashtable stores the categories and a queue for each order in those categories. It takes best case and worst case big O(m * n) time to generate the database. This is because n words for m number of lines. The running time to build the categories hashtable is O(n), where n is the number of lines in the file. It is big O(n) because we must read all the lines in the categories.txt file.

Our producer function parses orders.txt and creates and order for the queue after every line. We first lock all the queues because they are initially empty and we have not parsed the file. Our producer goes through the orders.txt line by line and after every line, we create an order that is placed in the appropriate category queue. If there are less than 10 orders in the queue, we unlock the queue and signal the consumer. If the queue for that category is full, then we wait for the consumer to process that queue. Otherwise, we continue adding the orders into the queues until the end of the file. After reading the whole file, we broadcast that the queues are nonempty.  

Our consumer function has an infinite loop and it processes the appropriate queue based on its category. If the queue is empty, the consumer unlocks the mutex on the queue and waits for the producer. If the queue is not empty, then the consumer process the orders in the queue. If the customer has enough credit for the book, then we print out a confirmation about the order. Otherwise, we print an order rejection. We store both the corfirmed and rejected orders in a global list. After an order is processed, we signal to producer to show that the queue is not full. 

After the producer and consumer threads are complete, we print out the receipt, confirmed orders, and rejected order. The running time is big O(n) because we traverse through each list once.  
