We used an external macros called uthash to create two hashtables. One hashtable stores the information for customers in the input database file and the other hashtable stores a queue for each category in the input categories file. It takes best case and worst case big O(n) time to generate the database, where n is the number of lines, or orders. The running time to build the categories hashtable is O(m), where m is the number of lines, or categories, in the file. 

Our producer function parses the book orders input file and adds an order to the appropriate queue after each line is read. Once it finishes reading an order from the file, it locks the qppropriate mutex. Before adding to the appropriate queue, it checks to see if it is full (contains 10 orders). If so, it signals to the appropriate consumer through a condition variable that the queue is full. It then waits until said consumer processes an order. Once there is space available in the queue, it adds the order and unlocks the mutex, signaling to the consumer that there is now data available. After all orders in the file are added to the queues, the producer function adds a poison order to each queue, agains signals that the queue is not empty, and returns.

Our consumer function has an infinite loop. Each consumer thread shares the appropriate queue of orders with the producer based on its category. First, it locks the mutex on the queue. Before processing an order, it checks to make sure there is an order in the queue. If not, it signals to the producer that the mutex has space available and waits until the queue is no longer empty. Once the queue has data to process, an order is dequeued from the queue and the order is processed. If the consumer decides that the order is a poison order, it breaks the infinite loop, unlocks the mutex, and exits gracefully. Otherwise, the order is determined to be either successful or unsuccessful based on the price of the book order and the customer's credit limit, and the function proceeds appropriately. Once the order is completely processed, the mutex is unlocked and the consumer signals to the producer that there is space available in the queue. 

After the producer and consumer threads are complete, all threads are joined and all mutexes and condition variables are destroyed. The final report is then printed, as well as the total revenue. The running time of the whole program is big O(n + m + k) where n is the number of customers in the database file, m is the number of categories in categories, and k is the number of book orders.
